const fs = require('fs/promises'); // For asynchronous file operations
const yaml = require('js-yaml');    // For parsing YAML files
const path = require('path');       // For path manipulations
const { PromisePool } = require('@supercharge/promise-pool'); // For controlling concurrency
const { exec, spawn } = require('child_process'); // For starting/stopping Clash processes
const { ProxyAgent } = require('undici'); // For configuring fetch to use a proxy

// --- Global Variables and Helper Functions ---

// Global proxy agent, to be instantiated in the main function
let globalProxyAgent;

/**
 * Tests the latency to a given URL through the configured proxy.
 * @param {string} url - The URL to test.
 * @param {number} timeout - Timeout in milliseconds.
 * @returns {Promise<number|string>} Latency in ms if successful, or an error string.
 */
async function testLatency(url, timeout = 5000) {
    const start = Date.now();
    let timeoutId;
    try {
        const controller = new AbortController();
        timeoutId = setTimeout(() => controller.abort(), timeout);

        const response = await fetch(url, {
            method: 'HEAD',
            redirect: 'follow',
            signal: controller.signal,
            dispatcher: globalProxyAgent // Use the global proxy agent
        });
        clearTimeout(timeoutId);

        if (response.ok) {
            return Date.now() - start; // Return latency in milliseconds
        } else {
            return `HTTP Error: ${response.status} ${response.statusText}`;
        }
    } catch (error) {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        if (error.name === 'AbortError') {
            return `超时 (${timeout}ms)`; // Timeout error
        } else if (error.cause && error.cause.code) {
            return `网络错误: ${error.cause.code}`; // Specific network error code (e.g., ECONNRESET, ECONNREFUSED)
        }
        return `连接错误: ${error.message.substring(0, 50)}...`; // General connection error
    }
}

/**
 * Tests the download speed from a given URL through the configured proxy.
 * @param {string} url - The URL to download from.
 * @param {number} sizeBytes - Expected download size in bytes.
 * @param {number} timeout - Timeout for the download in milliseconds.
 * @returns {Promise<string>} Download speed in Mbps or an error string.
 */
async function testDownloadSpeed(url, sizeBytes = 1000000, timeout = 10000) {
    const start = Date.now();
    let timeoutId;
    try {
        const controller = new AbortController();
        timeoutId = setTimeout(() => controller.abort(), timeout);

        const response = await fetch(url, {
            method: 'GET',
            signal: controller.signal,
            dispatcher: globalProxyAgent // Use the global proxy agent
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
            return `下载失败 (状态码: ${response.status})`;
        }

        const reader = response.body.getReader();
        let downloadedBytes = 0;
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            downloadedBytes += value.length;
            if (downloadedBytes >= sizeBytes) break; // Stop once desired size is reached
        }

        const duration = (Date.now() - start) / 1000; // Convert to seconds
        if (duration === 0) return "计算错误 (持续时间为0)";
        const speedMbps = (downloadedBytes * 8 / (1024 * 1024)) / duration; // Calculate Mbps
        return `${speedMbps.toFixed(2)} Mbps (${(downloadedBytes / (1024 * 1024)).toFixed(2)} MB)`;
    } catch (error) {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        if (error.name === 'AbortError') {
            return `下载超时 (${timeout}ms)`;
        } else if (error.cause && error.cause.code) {
            return `下载网络错误: ${error.cause.code}`;
        }
        return `下载测试异常: ${error.message.substring(0, 50)}...`;
    }
}

/**
 * Generates a temporary Clash configuration string for a given proxy.
 * @param {object} proxy - The proxy object from 520.yaml.
 * @returns {string} The YAML configuration string.
 */
function generateClashConfig(proxy) {
    const config = {
        'port': 7890,           // Clash HTTP proxy port
        'socks-port': 7891,     // Clash SOCKS5 proxy port
        'allow-lan': false,
        'mode': 'rule',         // Rule mode for MATCH rule to apply
        'log-level': 'info',    // Set to 'info' or 'debug' for debugging
        'external-controller': '127.0.0.1:9090', // Optional Clash dashboard port
        'proxies': [],
        'proxy-groups': [],
        'rules': []
    };

    // Sanitize proxy name for file paths or if used in config where special chars are forbidden
    const proxyName = (proxy.name || `proxy-${Math.random().toString(36).substring(7)}`).replace(/[^a-zA-Z0-9_-]/g, '_');

    let clashProxy = {
        name: proxyName,
        type: proxy.type,
        server: proxy.server,
        port: proxy.port,
        udp: proxy.udp || false, // Read UDP support from 520.yaml
        'skip-cert-verify': proxy['skip-cert-verify'] || false, // Default to not skipping cert verification
    };

    // Add type-specific parameters
    switch (proxy.type.toLowerCase()) {
        case 'vless':
            clashProxy.uuid = proxy.uuid;
            clashProxy.tls = proxy.tls || false;
            if (proxy.servername) { clashProxy.servername = proxy.servername; }
            if (proxy.alpn) { clashProxy.alpn = proxy.alpn; }
            if (proxy.network) { clashProxy.network = proxy.network; }
            if (proxy.network === 'ws' && proxy['ws-opts']) {
                clashProxy['ws-opts'] = {
                    path: proxy['ws-opts'].path || '/',
                    headers: proxy['ws-opts'].headers || {}
                };
            }
            if (proxy.network === 'grpc' && proxy['grpc-opts']) {
                clashProxy['grpc-opts'] = {
                    serviceName: proxy['grpc-opts'].serviceName || ''
                };
            }
            break;
        case 'trojan':
            clashProxy.password = proxy.password;
            clashProxy.tls = proxy.tls || false;
            if (proxy.servername) { clashProxy.servername = proxy.servername; }
            if (proxy.alpn) { clashProxy.alpn = proxy.alpn; }
            if (proxy.network) { clashProxy.network = proxy.network; }
            if (proxy.network === 'ws' && proxy['ws-opts']) {
                clashProxy['ws-opts'] = {
                    path: proxy['ws-opts'].path || '/',
                    headers: proxy['ws-opts'].headers || {}
                };
            }
            if (proxy.network === 'grpc' && proxy['grpc-opts']) {
                clashProxy['grpc-opts'] = {
                    serviceName: proxy['grpc-opts'].serviceName || ''
                };
            }
            break;
        case 'ss': // Shadowsocks
            clashProxy.cipher = proxy.cipher;
            clashProxy.password = proxy.password;
            if (proxy.obfs) { clashProxy.obfs = proxy.obfs; }
            if (proxy.obfsHost) { clashProxy.obfsHost = proxy.obfsHost; }
            if (proxy.plugin) { clashProxy.plugin = proxy.plugin; }
            if (proxy.pluginOpts) { clashProxy.pluginOpts = proxy.pluginOpts; }
            break;
        case 'ssr': // ShadowsocksR (Clash.Meta might have better SSR support)
            clashProxy.password = proxy.password;
            if (proxy.obfs) { clashProxy.obfs = proxy.obfs; }
            if (proxy.protocol) { clashProxy.protocol = proxy.protocol; }
            if (proxy.obfsparam) { clashProxy.obfsParam = proxy.obfsparam; }
            if (proxy.protoparam) { clashProxy.protocolParam = proxy.protoparam; }
            clashProxy.cipher = proxy.cipher;
            break;
        case 'vmess':
            clashProxy.uuid = proxy.uuid;
            clashProxy.alterId = proxy.alterId || 0;
            clashProxy.cipher = proxy.cipher || 'auto';
            clashProxy.tls = proxy.tls || false;

            if (proxy.servername) { clashProxy.servername = proxy.servername; }
            if (proxy.network) { clashProxy.network = proxy.network; }

            if (proxy.network === 'ws' && proxy['ws-opts']) {
                clashProxy['ws-opts'] = {
                    path: proxy['ws-opts'].path || '/',
                    headers: proxy['ws-opts'].headers || {}
                };
            }
            if (proxy.network === 'grpc' && proxy['grpc-opts']) {
                clashProxy['grpc-opts'] = {
                    serviceName: proxy['grpc-opts'].serviceName || ''
                };
            }
            break;
        case 'hysteria':
        case 'hy':
            clashProxy.auth = proxy.auth;
            clashProxy.network = proxy.network || 'udp';
            clashProxy.tls = proxy.tls || false;
            if (proxy.servername) { clashProxy.servername = proxy.servername; }
            if (proxy.alpn) { clashProxy.alpn = proxy.alpn; }
            if (proxy.ports) { clashProxy.ports = proxy.ports; }
            if (proxy.up) { clashProxy.up = proxy.up; }
            if (proxy.down) { clashProxy.down = proxy.down; }
            if (proxy.obfs) { clashProxy.obfs = proxy.obfs; }
            if (proxy.obfsParam) { clashProxy.obfsParam = proxy.obfsParam; }
            clashProxy.fastOpen = proxy.fastOpen || false;
            break;
        case 'hysteria2':
        case 'hy2':
            clashProxy.password = proxy.password;
            clashProxy.tls = proxy.tls || false;
            if (proxy.servername) { clashProxy.servername = proxy.servername; }
            if (proxy.alpn) { clashProxy.alpn = proxy.alpn; }
            clashProxy.fastOpen = proxy.fastOpen || false;
            // if (proxy['enable-multiplex']) { clashProxy['enable-multiplex'] = proxy['enable-multiplex']; }
            break;
        default:
            console.warn(`未知或不支持的代理类型，可能无法正确配置 Clash: ${proxy.type}`);
            break;
    }

    config.proxies.push(clashProxy);
    config['proxy-groups'].push({
        name: 'Proxy',
        type: 'select',
        proxies: [proxyName] // Reference the newly added proxy
    });
    config.rules.push('MATCH,Proxy'); // All traffic goes through the 'Proxy' group

    return yaml.dump(config, { lineWidth: -1 });
}

// --- Main Test Function ---
async function runNodeTests() {
    const inputFilePath = path.join(__dirname, 'data', '520.yaml');
    const outputConfigPath = path.join(__dirname, 'data', '521.yaml'); // For importable config
    const outputReportPath = path.join(__dirname, 'data', '521_detailed_report.yaml'); // For detailed report

    // Read and parse the input config file
    let proxiesConfig;
    try {
        const fileContent = await fs.readFile(inputFilePath, 'utf8');
        proxiesConfig = yaml.load(fileContent);
        if (!proxiesConfig || !Array.isArray(proxiesConfig.proxies)) {
            throw new Error('520.yaml 文件格式不正确，缺少 "proxies" 数组。');
        }
    } catch (error) {
        console.error(`读取或解析 520.yaml 失败: ${error.message}`);
        return {
            timestamp: new Date().toISOString(),
            error: `读取或解析 520.yaml 失败: ${error.message}`
        };
    }

    // Initialize global ProxyAgent here, Clash listens on HTTP port 7890
    globalProxyAgent = new ProxyAgent('http://127.0.0.1:7890');

    console.log(`开始测试 ${proxiesConfig.proxies.length} 个代理，最大并发数 5 (通过 Clash 客户端)...`);

    // Use PromisePool for concurrent testing
    const { results: testResults } = await PromisePool
        .for(proxiesConfig.proxies)
        .withConcurrency(5) // Increased concurrency for faster testing
        .process(async (proxy) => {
            const nodeName = proxy.name || "未知名称";
            // Sanitize node name for use in file paths
            const safeNodeName = nodeName.replace(/[^a-zA-Z0-9_-]/g, '_');
            const configFileName = `clash-config-${safeNodeName}.yaml`;
            const configFilePath = path.join(__dirname, 'temp', configFileName);
            const clashExecutablePath = path.join(__dirname, 'tools', 'clash'); // Path to Clash executable

            let clashProcess = null;
            let latency = "N/A";
            let downloadSpeed = "未测试";
            let status = "失败";

            console.log(`\n--- 正在测试代理: ${nodeName} (类型: ${proxy.type}) ---`);

            let result = {
                name: nodeName,
                server: proxy.server,
                port: proxy.port || (proxy.tls ? 443 : 80),
                type: proxy.type || "未知",
                test_target_url: 'https://www.google.com/generate_204',
                status: "未开始",
                latency_ms: "N/A",
                download_speed: "未测试"
            };

            try {
                // Ensure 'temp' directory exists
                await fs.mkdir(path.join(__dirname, 'temp'), { recursive: true });

                // 1. Generate Clash configuration
                const clashConfigContent = generateClashConfig(proxy);
                await fs.writeFile(configFilePath, clashConfigContent, 'utf8');
                console.log(`  - 已生成 Clash 配置: ${configFileName}`);

                // 2. Start Clash client
                clashProcess = spawn(clashExecutablePath, ['-f', configFilePath], {
                    detached: true, // Detach child process from parent
                    stdio: 'ignore' // Ignore stdout/stderr to prevent console flooding. Use 'inherit' for debugging.
                });

                clashProcess.unref(); // Allow Node.js process to exit independently of child

                // Listen for Clash process errors
                clashProcess.on('error', (err) => {
                    console.error(`  - Clash 进程错误 (${nodeName}): ${err.message}`);
                    status = `Clash启动错误: ${err.message.substring(0, 50)}...`;
                });

                clashProcess.on('exit', (code, signal) => {
                    if (code !== 0 && signal !== 'SIGTERM') {
                        console.warn(`  - Clash 进程异常退出 (${nodeName}): Code ${code}, Signal ${signal}`);
                        if (status === "未开始" || status === "失败") {
                            status = `Clash异常退出: Code ${code}`;
                        }
                    }
                });

                // 3. Wait for Clash to start and initialize
                await require('timers/promises').setTimeout(5000); // Give it 5 seconds to start

                // 4. Perform proxy test (e.g., access Google's no-content page)
                const testUrlForProxy = 'https://www.google.com/generate_204';
                console.log(`  - 正在通过代理测试 ${nodeName} 连接到 ${testUrlForProxy}`);

                latency = await testLatency(testUrlForProxy);

                if (typeof latency === 'number') {
                    status = "成功";
                    console.log(`  - ${nodeName} 延迟: ${latency}ms`);
                    // Only test download speed if latency test is successful
                    // You can uncomment and modify this to test download speed from a specific URL
                    // const downloadTestUrl = 'http://speedtest.tele2.net/1MB.zip'; // Example 1MB test file
                    // downloadSpeed = await testDownloadSpeed(downloadTestUrl, 1 * 1024 * 1024, 15000); // 1MB, 15s timeout
                    // console.log(`  - ${nodeName} 下载速度: ${downloadSpeed}`);
                } else {
                    status = `代理连接失败: ${latency}`;
                    console.log(`  - ${nodeName} 代理测试失败: ${latency}`);
                }

            } catch (testError) {
                console.error(`  - 测试代理 ${nodeName} 时发生未捕获异常:`, testError.message);
                status = `未捕获异常: ${testError.message.substring(0, 50)}...`;
            } finally {
                // 5. Stop Clash client and clean up temporary files
                if (clashProcess && !clashProcess.killed) {
                    try {
                        process.kill(clashProcess.pid, 'SIGTERM'); // Send SIGTERM signal
                        await require('timers/promises').setTimeout(1000); // Wait for termination
                        console.log(`  - 已尝试停止 Clash 进程 (PID: ${clashProcess.pid})`);
                    } catch (killError) {
                        console.warn(`  - 无法终止 Clash 进程 ${clashProcess.pid}:`, killError.message);
                    }
                }
                try {
                    await fs.unlink(configFilePath); // Delete temporary config file
                    console.log(`  - 已删除临时配置文件: ${configFileName}`);
                } catch (unlinkError) {
                    console.warn(`  - 无法删除临时配置文件 ${configFilePath}:`, unlinkError.message);
                }
            }

            // Update final result object
            result.status = status;
            result.latency_ms = latency;
            result.download_speed = downloadSpeed;
            return result;
        });

    // --- Post-processing: Filter successful proxies and generate output files ---

    // Filter out successful proxies
    const successfulProxies = testResults.filter(result => result.status === "成功");

    // Prepare proxies list for the new Clash config file
    const cleanProxiesForConfig = successfulProxies.map(proxyResult => {
        // Find the complete original proxy object from the initial 520.yaml
        // This is crucial because proxyResult only has a subset of fields needed for a full Clash config.
        const originalProxy = proxiesConfig.proxies.find(p => {
            const originalNameSafe = (p.name || `proxy-${Math.random().toString(36).substring(7)}`).replace(/[^a-zA-Z0-9_-]/g, '_');
            const resultNameSafe = proxyResult.name.replace(/[^a-zA-Z0-9_-]/g, '_');
            return originalNameSafe === resultNameSafe;
        });

        if (originalProxy) {
            // Create a streamlined object suitable for Clash configuration
            // Ensure all necessary fields for EACH proxy type are copied from originalProxy
            let configProxy = {
                name: originalProxy.name,
                type: originalProxy.type,
                server: originalProxy.server,
                port: originalProxy.port,
                udp: originalProxy.udp || false,
                'skip-cert-verify': originalProxy['skip-cert-verify'] || false,
            };

            switch (originalProxy.type.toLowerCase()) {
                case 'vless':
                    configProxy.uuid = originalProxy.uuid;
                    configProxy.tls = originalProxy.tls || false;
                    if (originalProxy.servername) configProxy.servername = originalProxy.servername;
                    if (originalProxy.alpn) configProxy.alpn = originalProxy.alpn;
                    if (originalProxy.network) configProxy.network = originalProxy.network;
                    if (originalProxy.network === 'ws' && originalProxy['ws-opts']) {
                        configProxy['ws-opts'] = originalProxy['ws-opts']; // Copy entire object
                    }
                    if (originalProxy.network === 'grpc' && originalProxy['grpc-opts']) {
                        configProxy['grpc-opts'] = originalProxy['grpc-opts']; // Copy entire object
                    }
                    break;
                case 'trojan':
                    configProxy.password = originalProxy.password;
                    configProxy.tls = originalProxy.tls || false;
                    if (originalProxy.servername) configProxy.servername = originalProxy.servername;
                    if (originalProxy.alpn) configProxy.alpn = originalProxy.alpn;
                    if (originalProxy.network) configProxy.network = originalProxy.network;
                    if (originalProxy.network === 'ws' && originalProxy['ws-opts']) {
                        configProxy['ws-opts'] = originalProxy['ws-opts'];
                    }
                    if (originalProxy.network === 'grpc' && originalProxy['grpc-opts']) {
                        configProxy['grpc-opts'] = originalProxy['grpc-opts'];
                    }
                    break;
                case 'ss':
                    configProxy.cipher = originalProxy.cipher;
                    configProxy.password = originalProxy.password;
                    if (originalProxy.obfs) configProxy.obfs = originalProxy.obfs;
                    if (originalProxy.obfsHost) configProxy.obfsHost = originalProxy.obfsHost;
                    if (originalProxy.plugin) configProxy.plugin = originalProxy.plugin;
                    if (originalProxy.pluginOpts) configProxy.pluginOpts = originalProxy.pluginOpts;
                    break;
                case 'ssr':
                    configProxy.password = originalProxy.password;
                    if (originalProxy.obfs) configProxy.obfs = originalProxy.obfs;
                    if (originalProxy.protocol) configProxy.protocol = originalProxy.protocol;
                    if (originalProxy.obfsparam) configProxy.obfsParam = originalProxy.obfsparam;
                    if (originalProxy.protoparam) configProxy.protocolParam = originalProxy.protoparam;
                    configProxy.cipher = originalProxy.cipher;
                    break;
                case 'vmess':
                    configProxy.uuid = originalProxy.uuid;
                    configProxy.alterId = originalProxy.alterId || 0;
                    configProxy.cipher = originalProxy.cipher || 'auto';
                    configProxy.tls = originalProxy.tls || false;
                    if (originalProxy.servername) configProxy.servername = originalProxy.servername;
                    if (originalProxy.network) configProxy.network = originalProxy.network;
                    if (originalProxy.network === 'ws' && originalProxy['ws-opts']) {
                        configProxy['ws-opts'] = originalProxy['ws-opts'];
                    }
                    if (originalProxy.network === 'grpc' && originalProxy['grpc-opts']) {
                        configProxy['grpc-opts'] = originalProxy['grpc-opts'];
                    }
                    break;
                case 'hysteria':
                case 'hy':
                    configProxy.auth = originalProxy.auth;
                    configProxy.network = originalProxy.network || 'udp';
                    configProxy.tls = originalProxy.tls || false;
                    if (originalProxy.servername) configProxy.servername = originalProxy.servername;
                    if (originalProxy.alpn) configProxy.alpn = originalProxy.alpn;
                    if (originalProxy.ports) configProxy.ports = originalProxy.ports;
                    if (originalProxy.up) configProxy.up = originalProxy.up;
                    if (originalProxy.down) configProxy.down = originalProxy.down;
                    if (originalProxy.obfs) configProxy.obfs = originalProxy.obfs;
                    if (originalProxy.obfsParam) configProxy.obfsParam = originalProxy.obfsParam;
                    configProxy.fastOpen = originalProxy.fastOpen || false;
                    break;
                case 'hysteria2':
                case 'hy2':
                    configProxy.password = originalProxy.password;
                    configProxy.tls = originalProxy.tls || false;
                    if (originalProxy.servername) configProxy.servername = originalProxy.servername;
                    if (originalProxy.alpn) configProxy.alpn = originalProxy.alpn;
                    configProxy.fastOpen = originalProxy.fastOpen || false;
                    // if (originalProxy['enable-multiplex']) configProxy['enable-multiplex'] = originalProxy['enable-multiplex'];
                    break;
                default:
                    console.warn(`WARN: 成功代理 '${originalProxy.name}' 类型 '${originalProxy.type}' 但未在生成可导入配置时完全映射。尝试保留原始信息。`);
                    return originalProxy; // Fallback to returning the original proxy if type not explicitly handled
            }
            return configProxy;
        }
        return null; // Exclude if original proxy not found (shouldn't happen if names are unique)
    }).filter(p => p !== null); // Filter out any null entries

    if (cleanProxiesForConfig.length === 0) {
        console.warn("\n没有发现任何成功的代理节点，跳过生成可导入的配置文件。");
        // If no successful proxies, still generate the detailed report
        const finalReport = {
            timestamp: new Date().toISOString(),
            tested_proxies_count: testResults.length,
            successful_proxies_count: 0,
            results: testResults
        };
        try {
            await fs.writeFile(outputReportPath, yaml.dump(finalReport, { lineWidth: -1 }), 'utf8');
            console.log(`\n测试报告已成功写入 ${outputReportPath} (没有成功的代理)。`);
        } catch (error) {
            console.error(`写入 ${outputReportPath} 失败: ${error.message}`);
        }
        return finalReport;
    }

    // Build the importable Clash configuration
    const importableConfig = {
        'port': 7890,
        'socks-port': 7891,
        'allow-lan': false,
        'mode': 'rule',
        'log-level': 'info',
        'external-controller': '127.0.0.1:9090',
        'proxies': cleanProxiesForConfig, // Contains all successful proxies
        'proxy-groups': [
            {
                name: 'Proxy',
                type: 'select',
                proxies: cleanProxiesForConfig.map(p => p.name) // Reference all successful proxy names
            },
            {
                name: 'Fallback', // Fallback group: tries proxies in order until one works
                type: 'fallback',
                proxies: cleanProxiesForConfig.map(p => p.name),
                url: 'http://www.gstatic.com/generate_204', // Health check URL
                interval: 300 // Check every 300 seconds
            },
            {
                name: 'Auto', // Auto-select group: selects best latency proxy
                type: 'url-test',
                proxies: cleanProxiesForConfig.map(p => p.name),
                url: 'http://www.gstatic.com/generate_204',
                interval: 300
            }
        ],
        'rules': [
            // Add common rules here. You can customize these.
            'DOMAIN-SUFFIX,google.com,Proxy',
            'DOMAIN-SUFFIX,youtube.com,Proxy',
            'DOMAIN-SUFFIX,netflix.com,Proxy',
            'DOMAIN-SUFFIX,facebook.com,Proxy',
            'DOMAIN-SUFFIX,twitter.com,Proxy',
            'DOMAIN-SUFFIX,wikipedia.org,Proxy',
            'GEOIP,CN,DIRECT', // Direct connection for Chinese IPs
            'MATCH,Proxy' // All other traffic goes through the 'Proxy' group
        ]
    };

    // Write the importable config file to data/521.yaml
    try {
        await fs.writeFile(outputConfigPath, yaml.dump(importableConfig, { lineWidth: -1 }), 'utf8');
        console.log(`\n已成功生成并写入可导入的 Clash 配置文件到 ${outputConfigPath}`);
    } catch (error) {
        console.error(`写入可导入配置文件到 ${outputConfigPath} 失败: ${error.message}`);
    }

    // Also write the detailed test report
    const finalReport = {
        timestamp: new Date().toISOString(),
        tested_proxies_count: testResults.length,
        successful_proxies_count: successfulProxies.length,
        results: testResults // Full test results
    };
    try {
        await fs.writeFile(outputReportPath, yaml.dump(finalReport, { lineWidth: -1 }), 'utf8');
        console.log(`详细测试报告已写入 ${outputReportPath}`);
    } catch (error) {
        console.error(`写入详细测试报告失败: ${error.message}`);
    }

    return finalReport;
}

// --- Script Execution ---
// Run tests when the script is executed directly
if (require.main === module) {
    runNodeTests().then(results => {
        console.log("\n--- 测试完成 ---");
        // console.log(JSON.stringify(results, null, 2)); // Uncomment for debugging JSON output
    }).catch(error => {
        console.error("运行测试时发生未捕获错误:", error);
        process.exit(1); // Exit with a non-zero code to indicate failure
    });
}
